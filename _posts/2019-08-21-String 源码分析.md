---
title: String 源码分析
tags: [Java,源码分析]
---

### 须知

1.String不属于基本数据类型.
2.String是Immutable(不可变的).String的大部分方法都会返回一个新的String.
3.Java对于String提供了编译期的运算符重载, String对于(+)的实现通过StringBuilder的append()方法.
4.Java默认提供了对于所有类转化为String类的方法, 即都继承了Object的toString()方法.

### 接口
```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
```

- Serializable序列化接口
- Comparable\<String> 比较接口
- CharSequence 字符串接口

看下CharSequence接口的方法, 是一些作为字符串的基础方法

```java
    int length();
    char charAt(int index);
    CharSequence subSequence(int start, int end);
    public String toString();
```
### 字段

```java
    private final char value[];
    private int hash; // Default to 0
    private static final long serialVersionUID = -6849794470754667710L;
    private static final ObjectStreamField[] serialPersistentFields =
        new ObjectStreamField[0];
```
- 基本数据类型字段一旦被设置为final, 对象初始化完成后, 该字段的`引用! 引用!`就不可变了
- hash值, 既然String是不可变的, 那么这里hash值肯定也是不可变的, 那么这里为什么不用`final`修饰? *如果要用final修饰, 那么就必须保证在构造函数中计算出hash值, 这样对于性能是有影响的*
- serialVersionUID 用于序列化的类型确认
- ObjectStreamField[] 用于序列化

### 构造方法
String可以用很多与之相关的参数值来进行构造.比如,String, 字符数组, 字节数组(可指定编码方式), StringBuffer,StringBuilder等
我们挑重点, 有思考价值的来看.
```java
    public String(char value[]) {
        this.value = Arrays.copyOf(value, value.length);
    }
    public String(StringBuffer buffer) {
        synchronized(buffer) {
            this.value = Arrays.copyOf(buffer.getValue(), buffer.length());
        }
    }
    public String(StringBuilder builder) {
        this.value = Arrays.copyOf(builder.getValue(), builder.length());
    }
```
- Arrays.copyOf 其实还是最后还是调用了System.arraycopy方法,这是一个JNI方法.
- 为什么要先复制在引用? `final char[] value`只能保证value引用的不可变性, value内部的元素还是可以改变的, 这里copy到该String实例内, 通过封装来保证不可变性.
	如果直接`this.value = value`那么, 一旦持有value的其他对象更改了value, 那么String就丧失了不可变性.
- StringBuffer是一个线程安全类, 为什么还要加上sychronized来保证进一步线程安全? 关键在于getValue()方法, 这是一个AbStractStringBuilder抽象类的方法, 所以该方法是不加锁的(也没法加锁, 不能保证锁的一致性), 那么length()方法带锁.getValue()不带锁就会造成线程安全问题, 所以这里getValue()加上(buffer)的同步锁.保证与其内部方法的锁(this)一致.
- StringBuilder线程不安全为什么不加锁? 那肯定的啦, 都知道是线程不安全的了, 那么就需要聪明的你去保证他在多线程中的安全问题. 

>该管的时候管, 不该管的时候不管, 性能和自由之道. - StringBuilder参数实例化String中学到

